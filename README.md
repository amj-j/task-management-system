# Task Management System
Task Management System is a web application built using Java and Spring Boot framework, designed to help users manage their tasks. It contains a graphical user web interface to create, read, update, and delete tasks, along with the option to categorize them into ones own categories.

## My motivation
In the "Object-Oriented Programming" course at my university, I was given a light indroduction into creating REST API with Spring boot and since I found it interesting, I decided to build this app on my own in the summer of 2023. I decided to create a graphical user web interface instead of REST API, so that I could practice building a whole app with all layers.

## Installation with Docker

### Prerequisites
- Docker compose

### Installation
1. In your terminal, navigate to the directory inside which you wish to download this repository
2. Clone this repository using command ```git clone https://github.com/amj-j/task-management-system.git```
3. Navigate inside the new directory which contains the cloned repository created by the previous command.
4. If your port ```8080``` is already occupied, in the ```docker-compose.yml``` file change the port configuration on line 8 from ```8080:8080``` to ```8081:8080``` or choose any other vacant port.
5. Execute this command to run the app: ```docker-compose up --build```. If ```docker-compose``` is unrecognized, run ```docker compose up --build```.
6. Open your browser and type ```localhost:8080``` (or replace ```8080``` with the port you chose in step 4). The index page of the app will open in your browser.
7. To terminate the app, go back to your terminal and press ```Ctrl + C```. This will kill the Docker compose process.

## Installation without Docker

### Prerequisites
- JDK 17 or higher
- Maven
- MySQL

### Installation
1. Create a new database in your MySQL that will serve as a database for this webapp
2. In your terminal, navigate to the directory inside which you wish to download this repository
3. Clone this repository using command ```git clone https://github.com/amj-j/task-management-system.git```
4. Open the ```src/main/resources/application.properties``` file in your IDE.
5. Replace the following (this disrupts the Docker compose setup):
   - ```${SPRING_DATASOURCE_URL}``` with ```jdbc:mysql://mysql:3306/your_db_name``` (instead of ```3306```, enter the port on which your MySQL database is running on and instead of ```your_db_name``` the name of your database created in step 1.)
   - ```${SPRING_DATASOURCE_USERNAME}``` with your MySQL database username you wish to use
   - ```${SPRING_DATASOURCE_PASSWORD}``` with your MySQL database password corresponding to the username
6. If your port ```8080``` is already occupied, add this line into the same ```application.properties``` file: ```server.port=8081``` and replace ```8081``` with a port you wish to run this app on.
7. In your terminal, navigate to the root directory of the repository (should be called ```task-management-system```)
8. Execute this command to download necessary dependencies and compile the app: ```mvn clean install```
9. Execute this command to run the app: ```mvn spring-boot:run```
10. Open your browser and type ```localhost:8080``` (or replace ```8080``` with the port you chose in step 4). The index page of the app will open in your browser.
11. To terminate the app, go back to your terminal and press ```Ctrl + C```. This will kill the Docker compose process.

## Architecture
This app implements MVC pattern in a way that is meant by Spring framework.

### Model
I used MySQL database to persist the information about users, their tasks and their task categories. With Spring data JPA dependency, I created entity classes and repository interfaces (interfaces that extend ```JpaRepository``` interface) to access the database and perform CRUD operations on it. (They serve as DAO.) Entities are data classes that can contain data from database tables. Repository interfaces contain method declarations that work with entity classes as arguments. These methods are called to perform the CRUD operations. The implementation of these methods (and classes containing them) is generated by Spring framework.

### Controller
I created Controller classes, and annotated them with Spring framework's ```@Controller``` annotation, so that Spring recognizes them as controllers. These classes contain handler methods with mappings to endpoints that are called upon HTTP requests from the users' computers. Outside the ```controller``` package, there is a ```service``` package, which contains service classes. These classes are a layer between repository interfaces and handler methods in controllers, which encapsulates the business logic. The handler methods in controllers call methods from service classes and those methods call repository methods. Service methods accept and return DTO (data transfer object) classes instead of entity classes, so that controller methods don't work with actual entity classes. This has multiple benefits like decoupling layers, better control of data format and more. 

### Dependency injection
Classes that implement repository interfaces, as well as service and controller classes are instantiated as "Spring-managed beans", which means Spring takes care of creating them and managing their lifecycle. Each class that has one or more fields of datatype that is a Spring-managed bean class (or interface that class implements), has these fields annotated with ```@Autowired``` annotation, which notifies Spring to inject the instances of those classes into these fields.

### View
The view is a set of ```.html``` files, each representing one webpage. These files have parametrized content provided by Thymeleaf dependency in my project. The parameter values are set inside controller methods, while Thymeleaf and Spring take care of assembling the actual static page along with the rest of the HTTP message that is sent to the user via internet using HTTP protocol.
